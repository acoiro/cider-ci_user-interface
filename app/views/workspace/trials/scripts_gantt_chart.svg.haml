
:ruby
  trial ||=  @trial || Trial.find(params[:id])
  cache_signature = CacheSignature.signature(trial)

- cache cache_signature do

  :ruby


    scripts = trial.scripts.with_indifferent_access.select{ |k,v|
      (v[:started_at] || v[:skipped_at]) && ( v[:finished_at] || v[:aborted_at] || v[:skipped_at])
    }.map{ |k, v|
      { key: k,
        state: v[:state],
        name: v[:name],
        started_at: Time.iso8601(v[:started_at] || v[:skipped_at]),
        finished_at: Time.iso8601(v[:finished_at] || v[:aborted_at] || v[:skipped_at])}
    }.map{|s|
      duration= s[:finished_at] - s[:started_at]
      s.merge(duration: duration)
    }.sort_by{|s| [s[:started_at],s[:finished_at]]}

    first_script_started_at = scripts.map{|s| s[:started_at]}.reduce{ |m, t| m < t ? m : t }

    scripts<< {key: 'prepare',
      state: 'unavailable',
      name: 'prepare',
      started_at: trial[:started_at],
      finished_at: first_script_started_at,
      duration: first_script_started_at - trial[:started_at] }


    scripts.sort_by!{|s| [s[:started_at],s[:finished_at]]}

    started_at = scripts.map{|s| s[:started_at]}.reduce{ |m, t| m < t ? m : t }

    finished_at = scripts.map{|s| s[:finished_at]}.reduce{ |m, t| m > t ? m : t}

    duration = finished_at - started_at

    width= 800
    row_height= 24
    row_margin= 12

    height= scripts.length * (row_height + row_margin)

    scale= ->(x){ (x - started_at) / duration * width  }

    script_rects = scripts.map.with_index{ |s,i|
      { x: scale.(s[:started_at]),
        y: i * (row_height + row_margin) + 1,
        height: row_height - 2,
        width: [s[:duration] / duration * width - 2, 1].max,
        class: "script #{s[:state]}"
      }
    }

    # LABELS ##################################################################

    labels = scripts.map.with_index{ |s,i|
      script = scripts[i]
      script_rect = script_rects[i]
      if script_rect[:x] <= width/2
        x= script_rect[:x] + 5
        anchor='start'
      else
        x= script_rect[:x] - 5
        anchor='end'
      end
      secs = script[:duration].round
      { x: x,
        y: script_rect[:y] + row_height/2,
        text: "#{script[:name]} (#{pluralize secs, 'second'})",
        'text-anchor': anchor,
        'dominant-baseline': 'central'
        }}


    # ARROWS ##################################################################

    scripts_key_map = scripts.map.with_index{|v, i|
        [v[:key],v.merge(rect: script_rects[i])]
      }.instance_eval{Hash[self]}


    arrows = scripts_key_map.map{|k,v| v}.map.with_index{|target, i|
      x2= target[:rect][:x]
      y2= target[:rect][:y] + row_height/2
      (trial.scripts[target[:key]].try(:[],'start-when') || []).map {|dependency|
        if source = (scripts_key_map[dependency['script']] rescue nil)
          states = dependency['states'] || ['passed']
          if states.include? 'executing'
            x1= source[:rect][:x]
          else
            x1= source[:rect][:x] + source[:rect][:width]
          end
          y1= source[:rect][:y] + row_height/2
          { x1: x1,
            y1: y1,
            x2: x2,
            y2: y2 }
        end
      }
    }.flatten.compact

  <?xml-stylesheet href="#{stylesheet_path('application')}" type="text/css" ?>

  %svg.scripts.timeline(x=0 y=0 width=width height=height
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        preserveAspectRatio="xMinYMin meet"
        viewBox="0 0 #{width} #{height}")

    %defs
      <marker id="tip" viewBox="0 -5 10 10" refX="15" refY="-1.5" markerWidth="6" markerHeight="6" orient="auto"><path d="M0,-5L10,0L0,5"></path></marker>

    - script_rects.each_with_index do |r,i|
      %rect.script-background{x: 0, y: r[:y] - 1 , width: width, height: row_height}

    - script_rects.each do |r|
      %rect{r.to_h}

    - arrows.each do |a|
      %line.start-dependency{a.to_h.merge('marker-end': "url(#tip)")}

    - labels.each_with_index do |l,i|
      %text{l.to_h}
        = l[:text]

